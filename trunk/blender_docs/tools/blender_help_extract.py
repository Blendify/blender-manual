import os
import re

# eg:
# python blender_help_extract.py /src/blender/source/creator/creator.c command_line_args.rst


def text_remove_comments(text):
    def replacer(match):
        s = match.group(0)
        if s.startswith('/'):
            return " "
        else:
            return s
    pattern = re.compile(
        r'//.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        re.DOTALL | re.MULTILINE
        )
    return re.sub(pattern, replacer, text)


def text_extract_args(text):
    args = {}
    # use replace to scan (misuse!)

    def replacer(match):
        fn = match.group(1)
        s = match.group(2)

        # remove first 2 args
        s = s.split(',', 2)[-1]
        # remove last 2 args
        s = s.rsplit(',', 2)[0]

        if fn == "BLI_argsAdd":
            # get first 2 args
            arg_short, arg_long, s = [w.strip() for w in s.split(",", 2)]
        elif fn == "BLI_argsAddCase":
            # get first 2 args
            arg_short, _, arg_long, _, s = [w.strip() for w in s.split(",", 4)]
            del _
        else:
            # should never happen
            raise Exception("Bad function call %r" % fn)

        if arg_short == "NULL":
            arg_short = None
        else:
            arg_short = eval(arg_short, {})
        if arg_long == "NULL":
            arg_long = None
        else:
            arg_long = eval(arg_long, {})
        args[arg_short, arg_long] = s

        # print(arg_short, arg_long, s)

    pattern = re.compile(
        r'\b(BLI_argsAdd[Case]*)\s*\(((?:(?!\)\s*;).)*?)\)\s*;',
        re.DOTALL | re.MULTILINE
        )

    re.sub(pattern, replacer, text)
    return args


def text_extract_strings(text):
    strings = {}
    # use replace to scan (misuse!)

    def replacer(match):
        var = match.group(1).strip()
        s = match.group(2)
        s = " ".join([w.strip() for w in s.split("\n")])
        s = eval(s, {})
        strings[var] = s

    pattern = re.compile(
        r'\bstatic\s+char\s+([A-Za-z0-9_]+)\[\]\s*=\s*((?:(?!"\s*;).)*?")\s*;',
        re.DOTALL | re.MULTILINE
        )

    re.sub(pattern, replacer, text)
    return strings


def text_extract_help(text, args, static_strings):
    func_id = 'static int print_help(int UNUSED(argc), const char **UNUSED(argv), void *data)\n'
    index_start = text.find(func_id)
    index_end = text.find("\texit(0);", index_start)
    # print(index_start, index_end)
    body = text[index_start + len(func_id):index_end]
    body = [l for l in body.split("\n") if not l.strip().startswith("#")]
    body = [l.strip() for l in body]
    body = [l for l in body if l]

    # args dicts
    args_short = {}
    args_long = {}
    args_used = set()

    for (arg_short, arg_long), value in args.items():
        if arg_short is not None:
            args_short[arg_short] = (arg_short, arg_long), value
        if arg_long is not None:
            args_long[arg_long] = (arg_short, arg_long), value
    # there is some overlap in short/long args, second pass to fix
    # by assigning long-only
    for (arg_short, arg_long), value in args.items():
        if arg_short is not None:
            if arg_long is None:
                args_short[arg_short] = (arg_short, arg_long), value

    def args_get(arg):
        value = args_long.get(arg)
        if value is None:
            value = args_short.get(arg)
            if value is None:
                raise Exception("Can't find %r" % arg)
        return value

    text_rst = [
        ".. DO NOT EDIT THIS FILE, GENERATED BY %r\n" % os.path.basename(__file__),
        "\n"
        "**********************\n"
        "Command Line Arguments\n"
        "**********************\n"
        "\n"
        ]

    # execute the code!
    other_vars = {
        "BLEND_VERSION_STRING_FMT": "Blender |BLENDER_VERSION| ",
        }


    def write_arg(arg):
        (arg_short, arg_long), arg_text = args_get(arg)
        args_used.add((arg_short, arg_long))

        # replacement table
        arg_text = re.sub("\"\s*STRINGIFY_ARG\s*\(([a-zA-Z0-9_]+)\)\"", r"``\1``", arg_text)
        arg_text = arg_text.replace('" STRINGIFY(BLENDER_MAX_THREADS) "', "64")
        arg_text = arg_text.replace('" STRINGIFY(BLENDER_STARTUP_FILE) "', "startup.blend")
        arg_text = arg_text.replace('" PY_ENABLE_AUTO', '\"')
        arg_text = arg_text.replace('" PY_DISABLE_AUTO', ', (default).\"')

        # print(arg_text)
        arg_text = eval(arg_text, static_strings)
        arg_text = arg_text.replace("\t", "   ")


        # in place of more advanced formatting
        arg_text = arg_text.replace(
                "* ani_##_test.png becomes ani_01_test.png",
                "\n   * ``ani_##_test.png`` becomes ``ani_01_test.png``"
                )

        text_rst.append("``" + "``, ``".join([w for w in (arg_short, arg_long) if w is not None]) + "`` ")
        text_rst.append(arg_text + "\n")


    for l in body:
        if l.startswith("printf"):
            l = eval(l[7:].strip("();"), other_vars)
            if l.lstrip() == l and l.strip("\n").endswith(":"):
                l = l.strip(":\n")
                l = "\n\n" + l + "\n" + len(l) * '=' + "\n\n"
            else:
                l = l.replace("\t", "   ")

            text_rst.append(l)
        elif l.startswith("BLI_argsPrintArgDoc("):
            arg = l.split(",")[-1].strip(");\n")
            arg = eval(arg, {})
            write_arg(arg)
        elif l.startswith("BLI_argsPrintOtherDoc("):
            items = list(args.items())
            # sort as strings since we cant order (None <> str)
            items.sort(key=lambda i: str(i[0]))
            for key, value in items:
                if key not in args_used:
                    write_arg(key[0] or key[1])

    text_rst = "".join(text_rst)

    # ------
    # Post process (formatting)
    # text_rst = re.split(r"\\n|[()]", text_rst)
    text_rst = text_rst.splitlines()

    for i, l in enumerate(text_rst):
        # detect env var list
        l_strip = l.lstrip()
        if l_strip.startswith("$"):
            l_strip, l_tail = l_strip.lstrip("$").split(" ", 1)
            if l_strip.isupper():
                l = ":%s: %s" % (l_strip, l_tail)
            del l_tail
        elif l_strip.startswith("#"):
            indent = l[:len(l) - len(l_strip)]
            l = "\n" + indent + ".. code-block:: sh\n\n" + indent + "   " + l.lstrip("# ") + "\n"
        else:
            # use "'" as "``", except when used as plural, eg "Python's"
            l = re.sub("(?<![a-z])'|'(?![st])", "``", l)
        del l_strip

        text_rst[i] = l.rstrip(" ")

    text_rst = "\n".join(text_rst)
    text_rst = text_rst.replace("\n\n\n\n", "\n\n\n")

    return text_rst


def main():
    import sys
    source_file = sys.argv[-2]
    output_file = sys.argv[-1]

    if not source_file.endswith("creator.c"):
        print("Expected 'creator.c' to be passed as the second last argument")
        return
    if not output_file.endswith(".rst"):
        print("Expected an '.rst' file to be passed as the last argument")
        return

    with open(source_file, 'r') as f:
        text = f.read()

    text = text_remove_comments(text)
    # first pass, extract 'BLI_argsAdd'

    args = text_extract_args(text)

    static_strings = text_extract_strings(text)

    text_rst = text_extract_help(text, args, static_strings)

    with open(output_file, 'w') as f:
        f.write(text_rst)

if __name__ == "__main__":
    main()

